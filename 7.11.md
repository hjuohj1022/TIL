# 7월 11일 (목)
## 1. MARKDOWN
- 일반 텍스트로 문서를 작성하는 간단한 방법
- 주로 개발자들이 텍스트와 코드를 작성해 문서화하기 위해 사용(워드, 한글에서 많이 사용)
- 작성된 마크다운 문서는 다른 프로그램에 의해 변환되어 출력됨
- 마크다운의 파일 확장자= .md

**마크다운의 주요연산자**

- 대제목의 연산자=#
#의 개수가 많아질수록 제목의 단위가 작아짐.

- 리스트
목록을 표시하기 위해 사용 (명령어=>-)
순서가 있는 리스트와 순서가 없는 리스트 제공

- 링크와 이미지
 - 특정 주소를 사용해 다른 페이지로 이동하는 링크 혹은 이미지를 출력
[]=실제 웹에서의 주소
()=링크주소
 - 앞쪽에 !가 들어가는 경우= 이미지를 출력
[]=만약 주소가 잘못되었을 경우 출력되는 글자(대체텍스트)

내가 가지고 있는 이미지 파일을 마크다운으로 쓰는 경우 
![](./파일명)=>파일명이랑 같은 위치에 있어야 함.

- *bold체  =>  **글자**
- 기울임 => *글자*
- 취소선 => ~~글자~~
- 수평선 => ---

- 인용문
-> >인용문
마크다운 가이드 
https://www.markdownguide.org/basic-syntax/

- 마크다운을 도와주는 마크다운 에디터
typora(유료)
marktext(무료)
markdown All in one(VS 확장프로그램)

## 2.CLI(Command Line Interface)
### 명령어를 통해 사용자와 컴퓨터가 상호 작용하는 방식이다.

### 왜 CLI를 사용해야 할까?
- 1)효율성
CLI는 키보드만으로 모든 작업을 수행할 수 있으며
메모리와 CPU 사용량이 적어 저사양 시스템에서도 효율적으로 동작
- 2) 정밀한 제어
특정 프로그램이나 시스템의 세부 설정을 보다 정밀하게 제어할 수 있음
- 3)표준성
CLI명령어는 대부분의 Unix 운영체제 기반 시스템에서 동일하게 작동하여 여러환경에서 적용할 수 있음
bash는 윈도우에 존재하지 않음

### 문법 및 활용
- CLI에서 점의 역할
- .(현재 디렉토리),
- ..(현재의 상위 디렉토리(부모 폴더))
- touch=파일 생성
- ~=홈 디렉토리
- mkdir=새 디렉토리 생성(폴더)
- cd= 현재 작업중인 디렉토리로 변경
- tab은 글자 자동완성 기능을 가지고 있음
- ls=현제화면은 보여주는 기능(디렉토리는 지울 수 없음)
- 디렉토리를 지우는 방법 =(rm -r 폴더명)
- start 폴더/파일을 열기

### CLI에서 가장 중요한것 
내가 어디에 있는지 알아야 한다

### 절대경로: C드라이브에서부터 시작 
### 상대경로: 현재 작업하고 잇는 디렉토리를 기준으로 계산된 상대적 위치를 작성한 것

## Git(중요) = (분산)버전 관리 시스템
버전 관리 = 변화를 기록하고 추적하는 것

버전 저장: 파일 전체를 기록하는 것이 아니라 이전 버전으로부터 변경사항을 저장하는 것이다.
그렇게 하는 이유: 차이점만 가지고 있음으로서 수정을 용이하게 하지 위해
 용량이 기하급수적으로 늘어가는 것을 방지하기 위해


중앙 집중식: 버전은 중앙 서버에 저장되고 중앙서버에서 파일을 가져와 다시 중앙에 업로드
분산식: 버전을 여러개의 복제된 저장소에 저장 및 관리
분산 구조에서의 장점
- 중앙 서버에 의존하지 않고도 동시에 다양한 작업을 수행할 수 있음
  개발자들 간의 작업 충동을 줄여주고 개발 생산성을 향상
- 중앙 서버의 장애나 손실에 대비하여 백업과 복구가 용이
- 인터넷에 연결되지 않은 환경에서도 작업을 계속할 수 있음


git의 역할
코드의 비전을 관리
개발되어 온 과정 파악
이전 버전과의 변경 사항 비교

git의 영역

- i Working Directory(빨간색): 실제 작업 중인 파일들이 위치하는 영역

- ii Staging Area(초록색): working directory에서 변경된 파일 중, 다음 버전에 포함시킬 파일들을 선택적으로 추가하거나 제외할 수 있는 중간 준비영역
(반드시 Staging Area를 거쳐야 함)

- iii Repository: 버전(commit) 이력과 파일들이 영구적으로 저장되는 영역, 모든버전과 변경 이력이 기록됨

Commit(버전): 변경된 파일들을 저장하는 행위이며, 마치 사진을 찍듯이 기록한다 하여 'snapshot'이라고도 함

- git init
로컬 저장소 설정(초기화)
git의 버전 관리를 시작할 디렉토리에서 진행

- 주의사항
git 로컬 저장소 내에 또다른 git 로컬 저장소를 만들지 말 것
(git저장소 안에 git저장소(하위 폴더에서 git init을 하는 경우)는 존재하지 않는다.)
git저장소를 제거하는 방법 = 폴더에서 숨긴항목안에 생성된 .git 폴더를 제거한다.

- git add 파일명
변경사항이 있는 파일을 staging area에 추가
파일을 생성되었다는 것을 추가
(버전과 드라이브는 전혀 다른 개념=> 파일 전체를 저장하는 것이 아님)

- git commit -m "하고싶은 이름"
staging area에 있는 파일들을 저장소에 기록
해당 시점의 버전을 생성하고 변경 이력을 남기는 것 

git config --global user.email "hjuohj1022@naver.com"
git config --global user.name "Your name"
->git 사용자가 누구인지 알려주는것

- git status
git의 상태를 알 수 있음(하지만 commit을 알 수는 없음)

- git log
commit된 파일들을 확인할 수 있음.

- 로컬: 현재 사용자가 직접 접속하고 있는 기기 또는 시스템
개임 컴퓨터, 노트북, 태블릿등 사용자가 직접 조장하는 환경

- Remote Repository
코드와 버전 관리 이력을 온라인 상의 특정 위치에 저장하여 여러 개발자가 협업하고 코드를 공유할 수 있는 저장 공간
Ex) Gitlab, GitHub, Bitbucket

- git remote add origin remote_repo_url
로컬 저장소에 원격 저장소 추가
origin =별칭을 사용해 로컬 저장소 한 개에 여러 원격 저장소를 추가 할 수 있음
remote_repo_url = 추가하는 원격 저장소의 URL

- push,(pull,clone)
git push origin master = 원격 저장소에 commit 목록을 업로드(변경사항만큼의  commit만 올린다.)

git은 드라이브의 개념이 아니기 때문에 무조건 commit하는 습관을 드려야 한다.

원격 저장소에는 commit이 올라가는 것(commit 이력이 없으면 할 수 없다.)

- pull(변경사항만)&clone(모든파일을 모두 다운로드)
집에 도착했을때 파일을 새로받는 경우 => clone
원격저장소가 업데이트되었을 때 변경사항을 받는 경우 => pull

- git clone remote_repo_url
원격 저장소 전체를 복제(이미 git init이 되어 있음)

- readme 파일을 생성하고 저장소를 만든 경우
먼저 로컬 저장소에 clone을 해주고 이후 과정을 진행한다.


- gitignore
git에서 추적하지 못하도록 설정하는 데 사용되는 텍스트 파일

gitignore
이미 git의 관리를 받은 이력이 있는 파일이나 디렉토리는 나중에 gitignore에 작성해도 적용되지 않음
(git rm --cashed 명령어를 통해 git 캐시에서 삭제 필요)
